import { WxWorkWebhook } from "./webhook.js";
import { sendMarkdownReply } from "./client.js";
import { logger } from "./logger.js";
import { streamManager } from "./stream-manager.js";


const DEFAULT_ACCOUNT_ID = "default";

// Runtime state (module-level singleton)
let _runtime = null;
let _moltbotConfig = null;

/**
 * Set the plugin runtime (called during plugin registration)
 */
function setRuntime(runtime) {
  _runtime = runtime;
}

function getRuntime() {
  if (!_runtime) {
    throw new Error("[wxwork] Runtime not initialized");
  }
  return _runtime;
}

// Webhook targets registry (similar to Google Chat)
const webhookTargets = new Map();

function normalizeWebhookPath(raw) {
  const trimmed = (raw || "").trim();
  if (!trimmed) return "/";
  const withSlash = trimmed.startsWith("/") ? trimmed : `/${trimmed}`;
  if (withSlash.length > 1 && withSlash.endsWith("/")) {
    return withSlash.slice(0, -1);
  }
  return withSlash;
}

function registerWebhookTarget(target) {
  const key = normalizeWebhookPath(target.path);
  const existing = webhookTargets.get(key) ?? [];
  webhookTargets.set(key, [...existing, { ...target, path: key }]);
  return () => {
    const updated = (webhookTargets.get(key) ?? []).filter((e) => e !== target);
    if (updated.length > 0) {
      webhookTargets.set(key, updated);
    } else {
      webhookTargets.delete(key);
    }
  };
}

// =============================================================================
// Channel Plugin Definition
// =============================================================================

const wxworkChannelPlugin = {
  id: "wxwork",
  meta: {
    id: "wxwork",
    label: "Enterprise WeChat",
    selectionLabel: "Enterprise WeChat (AI Bot)",
    docsPath: "/channels/wxwork",
    blurb: "Enterprise WeChat AI Bot channel plugin.",
    aliases: ["wecom", "wework"],
  },
  capabilities: {
    chatTypes: ["direct"],
    reactions: false,
    threads: false,
    media: false,
    nativeCommands: false,
    blockStreaming: true, // WxWork AI Bot uses stream response format
  },
  reload: { configPrefixes: ["channels.wxwork"] },
  config: {
    listAccountIds: (cfg) => {
      const wxwork = cfg?.channels?.wxwork;
      if (!wxwork || !wxwork.enabled) return [];
      return [DEFAULT_ACCOUNT_ID];
    },
    resolveAccount: (cfg, accountId) => {
      const wxwork = cfg?.channels?.wxwork;
      if (!wxwork) return null;
      return {
        id: accountId || DEFAULT_ACCOUNT_ID,
        accountId: accountId || DEFAULT_ACCOUNT_ID,
        enabled: wxwork.enabled !== false,
        token: wxwork.token || "",
        encodingAesKey: wxwork.encodingAesKey || "",
        webhookPath: wxwork.webhookPath || "/webhooks/wxwork",
        config: wxwork,
      };
    },
    defaultAccountId: (cfg) => {
      const wxwork = cfg?.channels?.wxwork;
      if (!wxwork || !wxwork.enabled) return null;
      return DEFAULT_ACCOUNT_ID;
    },
    setAccountEnabled: ({ cfg, accountId, enabled }) => {
      if (!cfg.channels) cfg.channels = {};
      if (!cfg.channels.wxwork) cfg.channels.wxwork = {};
      cfg.channels.wxwork.enabled = enabled;
      return cfg;
    },
    deleteAccount: ({ cfg, accountId }) => {
      if (cfg.channels?.wxwork) delete cfg.channels.wxwork;
      return cfg;
    },
  },
  directory: {
    self: async () => null,
    listPeers: async () => [],
    listGroups: async () => [],
  },
  // AI Bot doesn't use channel outbound - replies go via response_url
  gateway: {
    startAccount: async (ctx) => {
      const account = ctx.account;
      logger.info("WxWork gateway starting", { accountId: account.accountId, webhookPath: account.webhookPath });

      const unregister = registerWebhookTarget({
        path: account.webhookPath || "/webhooks/wxwork",
        account,
        config: ctx.cfg,
      });

      return {
        shutdown: async () => {
          logger.info("WxWork gateway shutting down");
          unregister();
        },
      };
    },
  },
};

// =============================================================================
// HTTP Webhook Handler
// =============================================================================

async function wxworkHttpHandler(req, res) {
  const url = new URL(req.url || "", "http://localhost");
  const path = normalizeWebhookPath(url.pathname);
  const targets = webhookTargets.get(path);

  if (!targets || targets.length === 0) {
    return false; // Not handled by this plugin
  }

  const query = Object.fromEntries(url.searchParams);
  logger.debug("WxWork HTTP request", { method: req.method, path });

  // GET: URL Verification
  if (req.method === "GET") {
    const target = targets[0]; // Use first target for verification
    if (!target) {
      res.writeHead(503, { "Content-Type": "text/plain" });
      res.end("No webhook target configured");
      return true;
    }

    const webhook = new WxWorkWebhook({
      token: target.account.token,
      encodingAesKey: target.account.encodingAesKey,
    });

    const echo = webhook.handleVerify(query);
    if (echo) {
      res.writeHead(200, { "Content-Type": "text/plain" });
      res.end(echo);
      logger.info("WxWork URL verification successful");
      return true;
    }

    res.writeHead(403, { "Content-Type": "text/plain" });
    res.end("Verification failed");
    logger.warn("WxWork URL verification failed");
    return true;
  }

  // POST: Message handling
  if (req.method === "POST") {
    const target = targets[0];
    if (!target) {
      res.writeHead(503, { "Content-Type": "text/plain" });
      res.end("No webhook target configured");
      return true;
    }

    // Read request body
    const chunks = [];
    for await (const chunk of req) {
      chunks.push(chunk);
    }
    const body = Buffer.concat(chunks).toString("utf-8");
    logger.debug("WxWork message received", { bodyLength: body.length });

    const webhook = new WxWorkWebhook({
      token: target.account.token,
      encodingAesKey: target.account.encodingAesKey,
    });

    const result = await webhook.handleMessage(query, body);
    if (!result) {
      res.writeHead(400, { "Content-Type": "text/plain" });
      res.end("Bad Request");
      return true;
    }

    // Handle text message - initiate stream response
    if (result.message) {
      const msg = result.message;
      const { timestamp, nonce } = result.query;

      // 生成流式消息ID
      const streamId = `stream_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      streamManager.createStream(streamId);

      // 被动回复：返回流式消息ID (同步响应)
      const streamResponse = webhook.buildStreamResponse(
        streamId,
        "", // 初始内容为空
        false, // 未完成
        timestamp,
        nonce
      );

      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(streamResponse);

      logger.info("Stream initiated", { streamId, from: msg.fromUser });

      // 异步处理消息 - 调用AI并更新流内容
      processInboundMessage({
        message: msg,
        streamId,
        timestamp,
        nonce,
        account: target.account,
        config: target.config,
      }).catch((err) => {
        logger.error("WxWork message processing failed", { error: err.message });
        // 即使失败也要标记流为完成
        streamManager.finishStream(streamId);
      });

      return true;
    }

    // Handle stream refresh - return current stream state
    if (result.stream) {
      const { timestamp, nonce } = result.query;
      const streamId = result.stream.id;

      // 获取流的当前状态
      const stream = streamManager.getStream(streamId);

      if (!stream) {
        // 流不存在或已过期,返回空的完成响应
        logger.warn("Stream not found for refresh", { streamId });
        const streamResponse = webhook.buildStreamResponse(
          streamId,
          "会话已过期",
          true,
          timestamp,
          nonce
        );
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(streamResponse);
        return true;
      }

      // 返回当前流的内容
      const streamResponse = webhook.buildStreamResponse(
        streamId,
        stream.content,
        stream.finished,
        timestamp,
        nonce
      );

      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(streamResponse);

      logger.debug("Stream refresh response sent", {
        streamId,
        contentLength: stream.content.length,
        finished: stream.finished
      });

      // 如果流已完成,在一段时间后清理
      if (stream.finished) {
        setTimeout(() => {
          streamManager.deleteStream(streamId);
        }, 30 * 1000); // 30秒后清理
      }

      return true;
    }

    // Handle event
    if (result.event) {
      logger.info("WxWork event received", { event: result.event });
      res.writeHead(200, { "Content-Type": "text/plain" });
      res.end("success");
      return true;
    }

    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("success");
    return true;
  }

  res.writeHead(405, { "Content-Type": "text/plain" });
  res.end("Method Not Allowed");
  return true;
}

// =============================================================================
// Inbound Message Processing (triggers AI response)
// =============================================================================

async function processInboundMessage({ message, streamId, timestamp, nonce, account, config }) {
  const runtime = getRuntime();
  const core = runtime.channel;

  const senderId = message.fromUser;
  const rawBody = message.content || "";
  const responseUrl = message.responseUrl;

  if (!rawBody.trim()) {
    logger.debug("WxWork: empty message, skipping");
    return;
  }

  logger.info("WxWork processing message", { from: senderId, content: rawBody.substring(0, 50), streamId });

  // Resolve agent route
  const route = core.routing.resolveAgentRoute({
    cfg: config,
    channel: "wxwork",
    accountId: account.accountId,
    peer: {
      kind: "dm",
      id: senderId,
    },
  });

  // Build inbound context
  const storePath = core.session.resolveStorePath(config.session?.store, {
    agentId: route.agentId,
  });
  const envelopeOptions = core.reply.resolveEnvelopeFormatOptions(config);
  const previousTimestamp = core.session.readSessionUpdatedAt({
    storePath,
    sessionKey: route.sessionKey,
  });

  const body = core.reply.formatAgentEnvelope({
    channel: "Enterprise WeChat",
    from: senderId,
    timestamp: Date.now(),
    previousTimestamp,
    envelope: envelopeOptions,
    body: rawBody,
  });

  const ctxPayload = core.reply.finalizeInboundContext({
    Body: body,
    RawBody: rawBody,
    CommandBody: rawBody,
    From: `wxwork:${senderId}`,
    To: `wxwork:${account.accountId}`,
    SessionKey: route.sessionKey,
    AccountId: route.accountId,
    ChatType: "direct",
    ConversationLabel: senderId,
    SenderName: senderId,
    SenderId: senderId,
    Provider: "wxwork",
    Surface: "wxwork",
    OriginatingChannel: "wxwork",
    OriginatingTo: `wxwork:${account.accountId}`,
  });

  // Record session meta
  void core.session.recordSessionMetaFromInbound({
    storePath,
    sessionKey: ctxPayload.SessionKey ?? route.sessionKey,
    ctx: ctxPayload,
  }).catch((err) => {
    logger.error("WxWork: failed updating session meta", { error: err.message });
  });

  // Dispatch reply with AI processing
  await core.reply.dispatchReplyWithBufferedBlockDispatcher({
    ctx: ctxPayload,
    cfg: config,
    dispatcherOptions: {
      deliver: async (payload, info) => {
        await deliverWxWorkReply({
          payload,
          account,
          responseUrl,
          senderId,
          streamId,  // 传递streamId用于流式更新
        });

        // 如果是最终回复,标记流为完成
        if (streamId && info.kind === "final") {
          streamManager.finishStream(streamId);
          logger.info("WxWork stream finished", { streamId });
        }
      },
      onError: (err, info) => {
        logger.error("WxWork reply failed", { error: err.message, kind: info.kind });
        // 发生错误时也标记流为完成
        if (streamId) {
          streamManager.finishStream(streamId);
        }
      },
    },
  });
}

// =============================================================================
// Outbound Reply Delivery (AI Bot - response_url only)
// =============================================================================

async function deliverWxWorkReply({ payload, account, responseUrl, senderId, streamId }) {
  const text = payload.text || "";

  // 流式模式：更新 streamManager
  if (streamId) {
    if (!text.trim()) {
      logger.debug("WxWork: empty block, skipping stream update");
      return;
    }

    // 检查流是否存在
    if (!streamManager.hasStream(streamId)) {
      logger.warn("WxWork: stream not found, cannot update", { streamId });
      return;
    }

    // 更新流内容 (全量替换,因为Moltbot每次deliver已经是累积的完整内容)
    streamManager.updateStream(streamId, text, false);

    logger.debug("WxWork stream updated", {
      streamId,
      contentLength: text.length,
      to: senderId
    });

    return;
  }

  // 兜底：非流式模式（旧逻辑,compatibility）
  if (!text.trim()) {
    logger.debug("WxWork: empty reply, skipping");
    return;
  }

  if (!responseUrl) {
    logger.error("WxWork: no response_url available for reply");
    return;
  }

  logger.info("WxWork delivering reply (non-streaming)", { to: senderId, length: text.length });

  try {
    await sendMarkdownReply(responseUrl, text);
    logger.info("WxWork reply sent successfully");
  } catch (e) {
    logger.error("WxWork reply failed", { error: e.message });
    throw e;
  }
}

// =============================================================================
// Plugin Registration
// =============================================================================

const plugin = {
  id: "wxwork",
  name: "Enterprise WeChat",
  description: "Enterprise WeChat AI Bot channel plugin for Moltbot",
  configSchema: { type: "object", additionalProperties: true, properties: {} },
  register(api) {
    logger.info("WxWork plugin registering...");

    // Save runtime for message processing
    setRuntime(api.runtime);
    _moltbotConfig = api.config;

    // Register channel
    api.registerChannel({ plugin: wxworkChannelPlugin });
    logger.info("WxWork channel registered");

    // Register HTTP handler for webhooks
    api.registerHttpHandler(wxworkHttpHandler);
    logger.info("WxWork HTTP handler registered");
  },
};

export default plugin;
export const register = (api) => plugin.register(api);
